{"version":3,"sources":["../src/Shaders.js"],"names":["invariant","require","INLINE_NAME","_uid","names","shaders","shadersCompileResponses","shadersCompileResults","shadersReferenceCounters","surfaceInlines","previousSurfaceInlines","makeDeferred","defer","p","Promise","resolve","reject","promise","implDefer","implementation","add","existingId","findShaderId","shader","id","name","then","impl","result","remove","getShadersToRemove","Object","keys","filter","map","parseInt","scheduled","gcNow","clearTimeout","forEach","scheduleGC","noDebounce","length","setTimeout","sameShader","a","b","frag","logError","console","error","Shaders","_onSurfaceWillMount","surfaceId","_onSurfaceWillUnmount","_beforeSurfaceBuild","_resolve","idOrObject","compileHandler","catch","get","inlines","push","_afterSurfaceBuild","create","obj","onAllCompile","compileErrors","compileResults","all","key","freeze","getCompilationResult","getCompilationPromise","list","exists","setImplementation","module","exports"],"mappings":"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","file":"Shaders.js","sourcesContent":["const invariant = require(\"invariant\");\n\nconst INLINE_NAME = \"<inline>\";\n\nlet _uid = 1;\nconst names = {}; // keep names\nconst shaders = {}; // keep shader objects\nconst shadersCompileResponses = {}; // keep promise of compile responses\nconst shadersCompileResults = {}; // keep only the successful result\nconst shadersReferenceCounters = {}; // reference count the shaders created with Shaders.create()/used inline so we don't delete them if one of 2 dups is still used\n\nconst surfaceInlines = {};\nconst previousSurfaceInlines = {};\n\nfunction makeDeferred() {\n  var defer = {};\n  var p = new Promise(function(resolve, reject) {\n    defer.resolve = resolve;\n    defer.reject = reject;\n  });\n  defer.promise = p;\n  return defer;\n}\n\nlet implDefer = makeDeferred();\nconst implementation = implDefer.promise;\n\nconst add = shader => {\n  const existingId = findShaderId(shaders, shader);\n  const id = existingId || _uid++;\n  let promise;\n  if (!existingId) {\n    names[id] = shader.name;\n    shaders[id] = shader;\n    shadersReferenceCounters[id] = 0;\n    shadersCompileResponses[id] = promise = implementation\n      .then(impl => impl.add(id, shader))\n      .then(result => (shadersCompileResults[id] = result));\n  } else {\n    promise = shadersCompileResponses[id];\n  }\n  return { id, promise };\n};\n\nconst remove = id => {\n  delete shaders[id];\n  delete names[id];\n  delete shadersReferenceCounters[id];\n  delete shadersCompileResponses[id];\n  implementation.then(impl => impl.remove(id));\n};\n\nconst getShadersToRemove = () =>\n  Object.keys(shadersReferenceCounters)\n    .filter(id => shadersReferenceCounters[id] <= 0)\n    .map(id => parseInt(id, 10));\n\nlet scheduled;\nconst gcNow = () => {\n  clearTimeout(scheduled);\n  getShadersToRemove().forEach(remove);\n};\nconst scheduleGC = () => {\n  // debounce the shader deletion to let a last chance to a future dup shader to appear\n  // the idea is also to postpone this operation when the app is not so busy\n  const noDebounce = getShadersToRemove().length > 20;\n  if (!noDebounce) clearTimeout(scheduled);\n  scheduled = setTimeout(gcNow, 500);\n};\n\nconst sameShader = (a, b) => a.frag === b.frag;\n\nconst findShaderId = (shaders, shader) => {\n  for (let id in shaders) {\n    if (sameShader(shaders[id], shader)) {\n      return parseInt(id, 10);\n    }\n  }\n  return null;\n};\n\nconst logError = shader => error =>\n  console.error(\n    //eslint-disable-line no-console\n    \"Shader '\" + shader.name + \"' failed to compile:\\n\" + error\n  );\n\nconst Shaders = {\n  _onSurfaceWillMount(surfaceId) {\n    surfaceInlines[surfaceId] = [];\n  },\n\n  _onSurfaceWillUnmount(surfaceId) {\n    surfaceInlines[surfaceId].forEach(id => shadersReferenceCounters[id]--);\n    delete surfaceInlines[surfaceId];\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  _beforeSurfaceBuild(surfaceId) {\n    previousSurfaceInlines[surfaceId] = surfaceInlines[surfaceId];\n    surfaceInlines[surfaceId] = [];\n  },\n\n  // Resolve the shader field of GL.Node.\n  // it can be an id (created with Shaders.create) or an inline object.\n  _resolve(idOrObject, surfaceId, compileHandler) {\n    if (typeof idOrObject === \"number\") return idOrObject;\n    const { id, promise } = add({ name: INLINE_NAME, ...idOrObject });\n    if (compileHandler) {\n      promise.then(\n        result => compileHandler(null, result),\n        error => compileHandler(error)\n      );\n    } else {\n      promise.catch(logError(Shaders.get(id)));\n    }\n    const inlines = surfaceInlines[surfaceId];\n    inlines.push(id);\n    return id;\n  },\n\n  _afterSurfaceBuild(surfaceId) {\n    previousSurfaceInlines[surfaceId].forEach(\n      id => shadersReferenceCounters[id]--\n    );\n    surfaceInlines[surfaceId].forEach(id => shadersReferenceCounters[id]++);\n    delete previousSurfaceInlines[surfaceId];\n    scheduleGC();\n  },\n\n  //~~~ Exposed methods ~~~ //\n\n  // Create shaders statically\n  create(obj, onAllCompile) {\n    invariant(typeof obj === \"object\", \"config must be an object\");\n    const result = {};\n    const compileErrors = {},\n      compileResults = {};\n    Promise.all(\n      Object.keys(obj).map(key => {\n        const shader = obj[key];\n        invariant(\n          typeof shader === \"object\" && typeof shader.frag === \"string\",\n          \"invalid shader given to Shaders.create(). A valid shader is a { frag: String }\"\n        );\n        const { id, promise } = add({ name: key, ...shader });\n        result[key] = id;\n        shadersReferenceCounters[id]++;\n        return promise.then(\n          result => (compileResults[key] = result),\n          error => (compileErrors[key] = error)\n        );\n      })\n    ).then(() => {\n      if (onAllCompile) {\n        onAllCompile(\n          Object.keys(compileErrors).length ? compileErrors : null,\n          compileResults\n        );\n      } else {\n        Object.keys(compileErrors).forEach(key =>\n          logError(Shaders.get(result[key]))(compileErrors[key])\n        );\n      }\n    });\n    return result;\n  },\n\n  // Get the shader object by id.\n  get(id) {\n    return Object.freeze(shaders[id]);\n  },\n\n  // Synchronously retrieve the successful compilation response.\n  // returns or ShaderResult object or null if there were a failure or not ready\n  getCompilationResult(id) {\n    return shadersCompileResults[id] || null;\n  },\n\n  // Get the promise of the compilation state. Allows you to wait for compilation\n  // and also map on errors.\n  // Returns null only if you never have created this shader.\n  getCompilationPromise(id) {\n    return shadersCompileResponses[id] || null;\n  },\n\n  // List all shader ids that exists at the moment.\n  list() {\n    return Object.keys(shaders);\n  },\n\n  // Check if a shader exists\n  exists(id) {\n    return id in shaders;\n  },\n\n  gcNow,\n\n  setImplementation: impl => {\n    invariant(implDefer, \"Shaders.setImplementation can be called only once\");\n    implDefer.resolve(impl);\n    implDefer = null;\n  },\n\n  implementation\n};\n\nmodule.exports = Object.freeze(Shaders);\n"]}