{"version":3,"sources":["../../src/data/build.js"],"names":["React","require","invariant","Uniform","Shaders","TextureObjects","duckTypeUniformValue","findGLNodeInGLComponentChildren","invariantStrictPositive","module","exports","build","glNode","context","parentPreload","via","surfaceId","decorateOnShaderCompile","props","shader","_resolve","onShaderCompile","glNodeUniforms","uniforms","width","height","pixelRatio","newContext","glNodeChildren","children","preload","exists","shaderName","get","name","contents","Children","forEach","child","type","displayName","opts","value","Object","keys","prototype","decorateUniformValue","withOpts","URI","uri","NDArray","res","childGLNode","push","vdom","uniform","data","e","message","process","env","NODE_ENV","console","error","Error"],"mappings":";;;;;;AAQA;;;;;;;;AARA,IAAMA,QAAQC,QAAQ,OAAR,CAAd;AACA,IAAMC,YAAYD,QAAQ,WAAR,CAAlB;AACA,IAAME,UAAUF,QAAQ,YAAR,CAAhB;AACA,IAAMG,UAAUH,QAAQ,YAAR,CAAhB;AACA,IAAMI,iBAAiBJ,QAAQ,kBAAR,CAAvB;AACA,IAAMK,uBAAuBL,QAAQ,wBAAR,CAA7B;AACA,IAAMM,kCAAkCN,QAAQ,mCAAR,CAAxC;AACA,IAAMO,0BAA0BP,QAAQ,2BAAR,CAAhC;;;AAGA;;AAEAQ,OAAOC,OAAP,GAAiB,SAASC,KAAT,CACfC,MADe,EAEfC,OAFe,EAGfC,aAHe,EAIfC,GAJe,EAKfC,SALe,EAMfC,uBANe,EAOf;AACA,MAAMC,QAAQN,OAAOM,KAArB;AACA,MAAMC,SAASf,QAAQgB,QAAR,CACbF,MAAMC,MADO,EAEbH,SAFa,EAGbC,wBAAwBC,MAAMG,eAA9B,CAHa,CAAf;AAKA,MAAMC,iBAAiBJ,MAAMK,QAA7B;;AAPA,oCAQ2CV,OAR3C,EAQuDK,KARvD;AAAA,MAQQM,KARR,kBAQQA,KARR;AAAA,MAQeC,MARf,kBAQeA,MARf;AAAA,MAQuBC,UARvB,kBAQuBA,UARvB;;AASA,MAAMC,aAAa;AACjBH,gBADiB;AAEjBC,kBAFiB;AAGjBC;AAHiB,GAAnB;AAKA,MAAME,iBAAiBV,MAAMW,QAA7B;AACA,MAAMC,UAAU,aAAaZ,KAAb,GAAqBA,MAAMY,OAA3B,GAAqChB,aAArD;;AAEAZ,YAAUE,QAAQ2B,MAAR,CAAeZ,MAAf,CAAV,EAAkC,4BAAlC,EAAgEA,MAAhE;;AAEA,MAAMa,aAAa5B,QAAQ6B,GAAR,CAAYd,MAAZ,EAAoBe,IAAvC;AACA1B,0BACEkB,UADF,EAEE,mBAAmBM,UAAnB,GAAgC,oBAFlC;;AAKA,MAAMT,wBAAgBD,cAAhB,CAAN;AACA,MAAMO,WAAW,EAAjB;AACA,MAAMM,WAAW,EAAjB;;AAEAnC,QAAMoC,QAAN,CAAeC,OAAf,CAAuBT,cAAvB,EAAuC,iBAAS;AAC9C1B,cACEoC,MAAMC,IAAN,KAAepC,OADjB,EAEE,+EAFF,EAGE6B,UAHF,EAIGM,MAAMC,IAAN,IAAcD,MAAMC,IAAN,CAAWC,WAA1B,IAA0CF,KAJ5C;;AAD8C,uBAOVA,MAAMpB,KAPI;AAAA,QAOtCgB,IAPsC,gBAOtCA,IAPsC;AAAA,QAOhCL,QAPgC,gBAOhCA,QAPgC;AAAA,QAOnBY,IAPmB;;AAQ9CvC,cACE,OAAOgC,IAAP,KAAgB,QAAhB,IAA4BA,IAD9B,EAEE,qDAFF,EAGEF,UAHF;AAKA9B,cACE,CAACoB,cAAD,IAAmB,EAAEY,QAAQZ,cAAV,CADrB,EAEE,kFAFF,EAGEU,UAHF;AAKA9B,cACE,EAAEgC,QAAQX,QAAV,CADF,EAEE,4FAFF,EAGES,UAHF;AAKAT,aAASW,IAAT,IACE,CAACL,QAAD,IAAaA,SAASa,KAAtB,GAA8Bb,QAA9B,GAAyC,EAAEa,OAAOb,QAAT,EAAmBY,UAAnB,EAD3C,CAvB8C,CAwBwB;AACvE,GAzBD;;AA2BAE,SAAOC,IAAP,CAAYrB,QAAZ,EAAsBc,OAAtB,CAA8B,gBAAQ;AACpC,QAAIK,QAAQnB,SAASW,IAAT,CAAZ;AAAA,QACEO,aADF;AAEA,QACEC,SACA,QAAOA,KAAP,yCAAOA,KAAP,OAAiB,QADjB,IAEA,CAACA,MAAMG,SAFP,IAGA,WAAWH,KAJb,EAKE;AACA;AACA,UAAI,QAAOA,MAAMD,IAAb,MAAsB,QAA1B,EAAoC;AAClCA,eAAOC,MAAMD,IAAb;AACD;AACDC,cAAQA,MAAMA,KAAd;AACD;;AAEDA,YAAQ,kBAAQI,oBAAR,CAA6BJ,KAA7B,CAAR;;AAEA,QAAI;AACF,cAAQpC,qBAAqBoC,KAArB,CAAR;AACE,aAAK,QAAL;AAAe;AACbnB,mBAASW,IAAT,IAAiB7B,eAAe0C,QAAf,CACf1C,eAAe2C,GAAf,CAAmB,EAAEC,KAAKP,KAAP,EAAnB,CADe,EAEfD,IAFe,CAAjB;AAIA;;AAEF,aAAK,OAAL;AAAc;AACZlB,mBAASW,IAAT,IAAiB7B,eAAe0C,QAAf,CACf1C,eAAe2C,GAAf,CAAmBN,KAAnB,CADe,EAEfD,IAFe,CAAjB;AAIA;;AAEF,aAAK,SAAL;AACElB,mBAASW,IAAT,IAAiB7B,eAAe0C,QAAf,CACf1C,eAAe6C,OAAf,CAAuBR,KAAvB,CADe,EAEfD,IAFe,CAAjB;AAIA;;AAEF,aAAK,QAAL;AACA,aAAK,MAAL;AAAa;AACX,gBAAMU,MAAM5C,gCAAgCmC,KAAhC,EAAuCf,UAAvC,CAAZ;AACA,gBAAIwB,GAAJ,EAAS;AAAA,kBACCC,WADD,GAC+BD,GAD/B,CACCC,WADD;AAAA,kBACcrC,IADd,GAC+BoC,GAD/B,CACcpC,GADd;AAAA,kBACmBF,QADnB,GAC+BsC,GAD/B,CACmBtC,OADnB;AAEP;;AACAgB,uBAASwB,IAAT,CAAc;AACZC,sBAAMZ,KADM;AAEZa,yBAASrB,IAFG;AAGZsB,sBAAM7C,MACJyC,WADI,EAEJvC,QAFI,EAGJiB,OAHI,EAIJf,IAJI,EAKJC,SALI,EAMJC,uBANI;AAHM,eAAd;AAYD,aAfD,MAeO;AACL;AACAkB,uBAASkB,IAAT,CAAc;AACZC,sBAAMZ,KADM;AAEZa,yBAASrB,IAFG;AAGZO;AAHY,eAAd;AAKD;AACD;AACD;;AAED;AACE;AACAlB,mBAASW,IAAT,IAAiBQ,KAAjB;AArDJ;AAuDD,KAxDD,CAwDE,OAAOe,CAAP,EAAU;AACV,aAAOlC,SAASW,IAAT,CAAP;AACA,UAAMwB,UACJ,aAAa1B,UAAb,GAA0B,cAA1B,GAA2CE,IAA3C,GAAkD,IAAlD,GAAyDuB,EAAEC,OAD7D;AAEA,UAAIC,QAAQC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2CC,QAAQC,KAAR,CAAcL,OAAd,EAAuBhB,KAAvB,EAJjC,CAIgE;AAC1E,YAAM,IAAIsB,KAAJ,CAAUN,OAAV,CAAN;AACD;AACF,GAjFD;;AAmFA,SAAO;AACLvC,kBADK;AAELI,sBAFK;AAGLC,gBAHK;AAILC,kBAJK;AAKLC,0BALK;AAMLG,sBANK;AAOLM,sBAPK;AAQLL,oBARK;AASLf;AATK,GAAP;AAWD,CA7JD","file":"build.js","sourcesContent":["const React = require(\"react\");\nconst invariant = require(\"invariant\");\nconst Uniform = require(\"../Uniform\");\nconst Shaders = require(\"../Shaders\");\nconst TextureObjects = require(\"./TextureObjects\");\nconst duckTypeUniformValue = require(\"./duckTypeUniformValue\");\nconst findGLNodeInGLComponentChildren = require(\"./findGLNodeInGLComponentChildren\");\nconst invariantStrictPositive = require(\"./invariantStrictPositive\");\nimport runtime from \"../runtime\";\n\n//// build: converts the gl-react VDOM DSL into an internal data tree.\n\nmodule.exports = function build(\n  glNode,\n  context,\n  parentPreload,\n  via,\n  surfaceId,\n  decorateOnShaderCompile\n) {\n  const props = glNode.props;\n  const shader = Shaders._resolve(\n    props.shader,\n    surfaceId,\n    decorateOnShaderCompile(props.onShaderCompile)\n  );\n  const glNodeUniforms = props.uniforms;\n  const { width, height, pixelRatio } = { ...context, ...props };\n  const newContext = {\n    width,\n    height,\n    pixelRatio\n  };\n  const glNodeChildren = props.children;\n  const preload = \"preload\" in props ? props.preload : parentPreload;\n\n  invariant(Shaders.exists(shader), \"Shader #%s does not exists\", shader);\n\n  const shaderName = Shaders.get(shader).name;\n  invariantStrictPositive(\n    pixelRatio,\n    \"GL Component (\" + shaderName + \"). pixelRatio prop\"\n  );\n\n  const uniforms = { ...glNodeUniforms };\n  const children = [];\n  const contents = [];\n\n  React.Children.forEach(glNodeChildren, child => {\n    invariant(\n      child.type === Uniform,\n      \"(Shader '%s') GL.Node can only contains children of type GL.Uniform. Got '%s'\",\n      shaderName,\n      (child.type && child.type.displayName) || child\n    );\n    const { name, children, ...opts } = child.props;\n    invariant(\n      typeof name === \"string\" && name,\n      \"(Shader '%s') GL.Uniform must define an name String\",\n      shaderName\n    );\n    invariant(\n      !glNodeUniforms || !(name in glNodeUniforms),\n      \"(Shader '%s') The uniform '%s' set by GL.Uniform must not be in {uniforms} props\",\n      shaderName\n    );\n    invariant(\n      !(name in uniforms),\n      \"(Shader '%s') The uniform '%s' set by GL.Uniform must not be defined in another GL.Uniform\",\n      shaderName\n    );\n    uniforms[name] =\n      !children || children.value ? children : { value: children, opts }; // eslint-disable-line no-undef\n  });\n\n  Object.keys(uniforms).forEach(name => {\n    let value = uniforms[name],\n      opts;\n    if (\n      value &&\n      typeof value === \"object\" &&\n      !value.prototype &&\n      \"value\" in value\n    ) {\n      // if value has a value field, we tread this field as the value, but keep opts in memory if provided\n      if (typeof value.opts === \"object\") {\n        opts = value.opts;\n      }\n      value = value.value;\n    }\n\n    value = runtime.decorateUniformValue(value);\n\n    try {\n      switch (duckTypeUniformValue(value)) {\n        case \"string\": // uri specified as a string\n          uniforms[name] = TextureObjects.withOpts(\n            TextureObjects.URI({ uri: value }),\n            opts\n          );\n          break;\n\n        case \"{uri}\": // uri specified in an object, we keep all other fields for RN \"local\" image use-case\n          uniforms[name] = TextureObjects.withOpts(\n            TextureObjects.URI(value),\n            opts\n          );\n          break;\n\n        case \"ndarray\":\n          uniforms[name] = TextureObjects.withOpts(\n            TextureObjects.NDArray(value),\n            opts\n          );\n          break;\n\n        case \"vdom[]\":\n        case \"vdom\": {\n          const res = findGLNodeInGLComponentChildren(value, newContext);\n          if (res) {\n            const { childGLNode, via, context } = res;\n            // We have found a GL.Node children, we integrate it in the tree and recursively do the same\n            children.push({\n              vdom: value,\n              uniform: name,\n              data: build(\n                childGLNode,\n                context,\n                preload,\n                via,\n                surfaceId,\n                decorateOnShaderCompile\n              )\n            });\n          } else {\n            // in other cases VDOM, we will use child as a content\n            contents.push({\n              vdom: value,\n              uniform: name,\n              opts\n            });\n          }\n          break;\n        }\n\n        default:\n          // Remaining cases will just set the value without further transformation\n          uniforms[name] = value;\n      }\n    } catch (e) {\n      delete uniforms[name];\n      const message =\n        \"Shader '\" + shaderName + \"': uniform '\" + name + \"' \" + e.message;\n      if (process.env.NODE_ENV !== \"production\") console.error(message, value); // eslint-disable-line no-console\n      throw new Error(message);\n    }\n  });\n\n  return {\n    shader,\n    uniforms,\n    width,\n    height,\n    pixelRatio,\n    children,\n    contents,\n    preload,\n    via\n  };\n};\n"]}